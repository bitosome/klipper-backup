[gcode_macro START_PRINT]
description: Machine heatup procedure before starting a print
variable_bed_temp: 0
variable_extruder_temp: 0
variable_z_adjust: 0
variable_soak: 0
variable_chamber_temp: 0
variable_chamber_maxtime: 0
variable_initial_tool: 0
variable_check_gates: 0
variable_tools_used: ""
variable_sync_mmu_extruder: 0
variable_material: "XXX"
variable_fl_size: "0_0_0_0"
variable_bed_mesh_profile: ""
variable_total_layer: 0
variable_adaptive_primeline: 1
gcode:
    # Get all the parameters passed from the slicer
    {% set BED_TEMP = params.BED_TEMP|default(printer["gcode_macro _USER_VARIABLES"].print_default_bed_temp)|float %} # Bed temperature
    {% set EXTRUDER_TEMP = params.EXTRUDER_TEMP|default(printer["gcode_macro _USER_VARIABLES"].print_default_extruder_temp)|float %} # Extruder temperature
    {% set Z_ADJUST = params.Z_ADJUST|default(0)|float %}  # Optionnal Z adjustement from the slicer profile (ex. use it if you have textured vs smooth slicer profiles) 
    {% set SOAK = params.SOAK|default(printer["gcode_macro _USER_VARIABLES"].print_default_soak)|int %} # Heatsoak time of the bed in minutes
    {% set CHAMBER_TEMP = params.CHAMBER|default(printer["gcode_macro _USER_VARIABLES"].print_default_chamber_temp)|int %} # Chamber temperature setpoint
    {% set CHAMBER_MAXTIME = params.CHAMBER_MAXTIME|default(printer["gcode_macro _USER_VARIABLES"].print_default_chamber_max_heating_time)|int %} # Chamber heatsoak timeout in minutes
    {% set INITIAL_TOOL = params.INITIAL_TOOL|default(0)|int %} # Initial tool (for the MMU/ERCF initialization)
    {% set MATERIAL = params.MATERIAL|default(printer["gcode_macro _USER_VARIABLES"].print_default_material)|string %} # Material type set in the slicer
    {% set FL_SIZE = params.SIZE|default("0_0_0_0")|string %} # Get bounding box of the first layer for the adaptive bed mesh
    {% set CHECK_GATES = params.CHECK_GATES|default(printer['gcode_macro _USER_VARIABLES'].mmu_check_gates_on_start_print)|default(0)|int %} # Check if MMU gates are availables
    {% set TOOLS_USED = params.TOOLS_USED|default("")|string %} # Check if MMU gates (used in gcode file) are availables
    {% set SYNC_MMU_EXTRUDER = params.SYNC_MMU_EXTRUDER|default(0)|int %} # set MMU gear motor and extruder synchronization during print TODO
    {% set BED_MESH_PROFILE = params.MESH|default("")|string %} # Bed mesh profile to load
    {% set ADAPTIVE_PRIMELINE = params.ADAPTIVE_PRIMELINE|default(1)|int %} # Weither to do or not an adaptive prime line near the real print zone

    # Set the variables to be used in all the modules based on the slicer parameters
    SET_GCODE_VARIABLE MACRO=START_PRINT VARIABLE=bed_temp VALUE={BED_TEMP}
    SET_GCODE_VARIABLE MACRO=START_PRINT VARIABLE=extruder_temp VALUE={EXTRUDER_TEMP}
    SET_GCODE_VARIABLE MACRO=START_PRINT VARIABLE=soak VALUE={SOAK}
    SET_GCODE_VARIABLE MACRO=START_PRINT VARIABLE=chamber_temp VALUE={CHAMBER_TEMP}
    SET_GCODE_VARIABLE MACRO=START_PRINT VARIABLE=chamber_maxtime VALUE={CHAMBER_MAXTIME}
    SET_GCODE_VARIABLE MACRO=START_PRINT VARIABLE=initial_tool VALUE={INITIAL_TOOL}
    SET_GCODE_VARIABLE MACRO=START_PRINT VARIABLE=check_gates VALUE={CHECK_GATES}
    SET_GCODE_VARIABLE MACRO=START_PRINT VARIABLE=tools_used VALUE='"{TOOLS_USED}"'
    SET_GCODE_VARIABLE MACRO=START_PRINT VARIABLE=sync_mmu_extruder VALUE={SYNC_MMU_EXTRUDER}
    SET_GCODE_VARIABLE MACRO=START_PRINT VARIABLE=material VALUE='"{MATERIAL}"'
    SET_GCODE_VARIABLE MACRO=START_PRINT VARIABLE=fl_size VALUE='"{FL_SIZE}"'
    SET_GCODE_VARIABLE MACRO=START_PRINT VARIABLE=bed_mesh_profile VALUE='"{BED_MESH_PROFILE}"'
    SET_GCODE_VARIABLE MACRO=START_PRINT VARIABLE=adaptive_primeline VALUE={ADAPTIVE_PRIMELINE}
    
    {% if params.TOTAL_LAYER %} # total layers count (if provided by the slicer)
        SET_PRINT_STATS_INFO TOTAL_LAYER={params.TOTAL_LAYER|int}
        SET_GCODE_VARIABLE MACRO=START_PRINT VARIABLE=total_layer VALUE={params.TOTAL_LAYER|int}
    {% endif %}

    # Get all the config options and configurations for this macro
    {% set verbose = printer["gcode_macro _USER_VARIABLES"].verbose %}
    {% set light_enabled = printer["gcode_macro _USER_VARIABLES"].light_enabled %}
    {% set light_intensity_start_print = printer["gcode_macro _USER_VARIABLES"].light_intensity_start_print %}
    {% set light_intensity_printing = printer["gcode_macro _USER_VARIABLES"].light_intensity_printing %}
    {% set status_leds_enabled = printer["gcode_macro _USER_VARIABLES"].status_leds_enabled %}
    {% set force_homing_in_start_print = printer["gcode_macro _USER_VARIABLES"].force_homing_in_start_print %}
    {% set bed_mesh_enabled = printer["gcode_macro _USER_VARIABLES"].bed_mesh_enabled %}
    {% set filter_enabled = printer["gcode_macro _USER_VARIABLES"].filter_enabled %}
    {% set part_fan_tach_enabled = printer["gcode_macro _USER_VARIABLES"].part_fan_tach_enabled %}
    {% set hotend_fan_tach_enabled = printer["gcode_macro _USER_VARIABLES"].hotend_fan_tach_enabled %}

    {% if MATERIAL not in printer["gcode_macro _USER_VARIABLES"].material_parameters %}
        RESPOND MSG="Material '{MATERIAL}' is unknown!"
        { action_raise_error("Add this new material to your material_parameters variable!") }
    {% else %}
        RESPOND MSG="Material '{MATERIAL}' is used"
        {% set material = printer["gcode_macro _USER_VARIABLES"].material_parameters[MATERIAL] %}
    {% endif %}


    # --------------------------------
    # Let's do the START_PRINT actions
    # --------------------------------

    {% if status_leds_enabled %}
        STATUS_LEDS COLOR="BUSY"
    {% endif %}

    {% if light_enabled %}
        LIGHT_ON S={light_intensity_start_print}
    {% endif %}

    CLEAR_PAUSE

    {% if bed_mesh_enabled %}
        BED_MESH_CLEAR
    {% endif %}

    # If a filter is enabled and already running due to a print that just finished, we stop
    # it now and deactivate the pending delayed gcode that could be running. The filter
    # could be restarted later in the START_PRINT sequence depending of the parameters
    {% if filter_enabled %}
        UPDATE_DELAYED_GCODE ID=_STOP_FILTER_DELAYED DURATION=0
        STOP_FILTER
    {% endif %}

    # If a tachometer is enabled on one of the fans, we check them:
    #   - It's done only once for the part fan to be sure nothing block it before starting the print
    #   - And as a safety feature, we start a monitoring loop for the hotend fan (that is automatically stopped at the end of a print)
    {% if part_fan_tach_enabled %}
        M106 S255
        G4 P2000
        _PART_FAN_CHECK
        M106 S0
    {% endif %}
    {% if hotend_fan_tach_enabled %}
        UPDATE_DELAYED_GCODE ID=_BACKGROUND_HOTEND_TACHO_CHECK DURATION=1
    {% endif %}

    SET_GCODE_OFFSET Z=0
    M221 S100
    M220 S100
    G90
    M83

    # Material parameters
    {% if firmware_retraction_enabled %}
        SET_RETRACTION RETRACT_LENGTH={material.retract_length} RETRACT_SPEED={material.retract_speed} UNRETRACT_EXTRA_LENGTH={material.unretract_extra_length} UNRETRACT_SPEED={material.unretract_speed}
    {% endif %}
    SET_PRESSURE_ADVANCE ADVANCE={material.pressure_advance}

    # Homing before START_PRINT movements and actions
    {% if force_homing_in_start_print %}
        G28
    {% else %}
        _CG28
    {% endif %}

    # Here is the core of the START_PRINT were we get the startprint_actions variable
    # to do the procedure in the correct order for the configured probe (or user custom override)
    {% set sp_actions = printer["gcode_macro _USER_VARIABLES"].startprint_actions %}
    {% for action in sp_actions %}
        {% if action == "bed_soak" %}
            _MODULE_HEATSOAK_BED
        {% elif action == "chamber_soak" %}
            _MODULE_HEATSOAK_CHAMBER
        {% elif action == "tilt_calib" %}
            _MODULE_TILTING
        {% elif action == "extruder_heating" %}
            _MODULE_EXTRUDER_HEATING
        {% elif action == "purge" %}
            _MODULE_PURGE
        {% elif action == "clean" %}
            _MODULE_CLEAN
        {% elif action == "z_offset" %}
            _MODULE_Z_CALIB
        {% elif action == "bedmesh" %}
            _MODULE_BED_MESH
        {% elif action == "primeline" %}
            _MODULE_PRIMELINE
        {% elif action == "extruder_preheating" %}
            _MODULE_EXTRUDER_PREHEATING
        {% else %}
            { action_raise_error("Unknown module called in START_PRINT! Please verify your startprint_actions variable override!") }
        {% endif %}
    {% endfor %}

    # Fine adjustement of z offset (from the slicer profile). This is used to do a custom adjustement
    # when using textured/smooth PEI sheets, or for a special material from the slicer, etc...
    SET_GCODE_OFFSET Z_ADJUST={Z_ADJUST} MOVE=1

    # Final material parameters
    SET_GCODE_OFFSET Z_ADJUST={material.additional_z_offset} MOVE=1
    {% if filter_enabled %}
        START_FILTER SPEED={material.filter_speed / 100}
    {% endif %}

    {% if filament_sensor_enabled and not material.filament_sensor %}
        SET_FILAMENT_SENSOR SENSOR="runout_sensor" ENABLE=0
    {% endif %}

    {% if status_leds_enabled %}
        STATUS_LEDS COLOR="PRINTING"
    {% endif %}

    {% if light_enabled %}
        LIGHT_ON S={light_intensity_printing}
    {% endif %}

    {% if verbose %}
        RESPOND MSG="Printing"
    {% endif %}

    G92 E0.0


[gcode_macro _MODULE_PRIMELINE]
gcode:
    # ----- PRIME LINE -------------------------------------------
    {% set FL_SIZE = printer["gcode_macro START_PRINT"].fl_size %}
    {% set ADAPTIVE_PRIMELINE = printer["gcode_macro START_PRINT"].adaptive_primeline %}
    {% set verbose = printer["gcode_macro _USER_VARIABLES"].verbose %}

    {% if verbose %}
        RESPOND MSG="Executing a primeline..."
    {% endif %}
    PRIMELINE SIZE={FL_SIZE} ADAPTIVE_MODE={ADAPTIVE_PRIMELINE}


[gcode_macro _MODULE_HEATSOAK_BED]
gcode:
    # ----- BED HEATSOAK -------------------------------------
    # Heatsoak the bed if SOAK time is set and bed is not already warming up to the correct temperature (+-8°C).
    # We make the assumption that the soak is not needed if the bed is already at the correct target.
    # We also use the recirculating filter under the bed (if available) at full power to spread the heat
    # during the heatsoak if a specific temperature need to be reached.
    {% set BED_TEMP = printer["gcode_macro START_PRINT"].bed_temp %}
    {% set SOAK = printer["gcode_macro START_PRINT"].soak %}
    {% set CHAMBER_TEMP = printer["gcode_macro START_PRINT"].chamber_temp %}

    {% set status_leds_enabled = printer["gcode_macro _USER_VARIABLES"].status_leds_enabled %}
    {% set filter_enabled = printer["gcode_macro _USER_VARIABLES"].filter_enabled %}

    {% set St = printer["gcode_macro _USER_VARIABLES"].travel_speed * 60 %}

    {% set max_x = printer.toolhead.axis_maximum.x|float %}
    {% set max_y = printer.toolhead.axis_maximum.y|float %}

    {% if status_leds_enabled %}
        STATUS_LEDS COLOR="HEATING"
    {% endif %}

    {% if printer.heater_bed.temperature < (BED_TEMP - 8) %}
        # If the machine is equiped by a chamber temperature sensor and a recirculating filter (check is automatic under the hood),
        # then we look if a specific chamber temperature is needed and we power on the recirculating filter to spread the heat
        {% if (CHAMBER_TEMP > 0) and filter_enabled %}
            START_FILTER SPEED=1
        {% endif %}

        # If we need a full soak (not 0 min), then move the toolhead to the center front to spread the heat using the hotend fan
        {% if SOAK > 0 %}
            G0 X{max_x|int / 2} Y{max_y|int / 3} Z50 F{St}
        {% endif %}
    
        # Put the bed temperature target and wait for the soak
        HEATSOAK_BED TEMP={BED_TEMP} SOAKTIME={SOAK}
    {% else %}
        HEATSOAK_BED TEMP={BED_TEMP} SOAKTIME=0
    {% endif %}


[gcode_macro _MODULE_HEATSOAK_CHAMBER]
gcode:
    # ----- CHAMBER HEATSOAK ----------------------------------
    # If a setpoint is defined and a sensor available, then we wait to reach the chamber temperature (with a timeout in case it's winter...)
    # If there is one, the recirculating filter is also be powered on from the previous step and kept like that to act as bed fans
    {% set CHAMBER_TEMP = printer["gcode_macro START_PRINT"].chamber_temp %}
    {% set CHAMBER_MAXTIME = printer["gcode_macro START_PRINT"].chamber_maxtime %}

    {% set chamber_sensor_enabled = printer["gcode_macro _USER_VARIABLES"].chamber_temperature_sensor_enabled %}
    {% set filter_enabled = printer["gcode_macro _USER_VARIABLES"].filter_enabled %}

    {% set St = printer["gcode_macro _USER_VARIABLES"].travel_speed * 60 %}

    {% set max_x = printer.toolhead.axis_maximum.x|float %}
    {% set max_y = printer.toolhead.axis_maximum.y|float %}

    {% if chamber_sensor_enabled %}
        {% if CHAMBER_TEMP > 0 %}
            {% set chamber_sensor_name = printer["gcode_macro _USER_VARIABLES"].chamber_temperature_sensor_name %}
            {% set CURRENT_TEMP = printer["temperature_sensor " ~ chamber_sensor_name].temperature|float %}

            # We do a first test to validate that the chamber is not already at temperature before starting the soak
            {% if CURRENT_TEMP <= CHAMBER_TEMP %}
                G0 X{max_x|int / 2} Y{max_y|int / 3} Z50 F{St}

                # Start the filter (if available) to spread the heat faster in the chamber
                {% if filter_enabled %}
                    START_FILTER SPEED=1
                {% endif %}

                # Wait for the temperature of the chamber to be reached (default max: 15min)
                HEATSOAK_CHAMBER TEMP={CHAMBER_TEMP} MAXTIME={CHAMBER_MAXTIME}

                # Reset the filter status now that the chamber is at correct temperature
                {% if filter_enabled %}
                    STOP_FILTER
                {% endif %}
            {% endif %}
        {% endif %}
    {% endif %}


[gcode_macro _MODULE_TILTING]
gcode:
    # ----- TILTING ----------------------------------
    # Do a QGL, Z_TILT_ADJUST, or nothing depending of the machine configuration
    # The correct operation is automatically selected in the _TILT_CALIBRATE macro
    {% set force_homing_in_start_print = printer["gcode_macro _USER_VARIABLES"].force_homing_in_start_print %}
    _TILT_CALIBRATE FORCE={force_homing_in_start_print}


[gcode_macro _MODULE_EXTRUDER_HEATING]
gcode:
    # ----- EXTRUDER HEATING ---------------------------------
    # Heat the nozzle to print temperature ontop of the purge bucket (if available) or in the middle of the bed
    {% set EXTRUDER_TEMP = printer["gcode_macro START_PRINT"].extruder_temp %}
    {% set INITIAL_TOOL = printer["gcode_macro START_PRINT"].initial_tool %}

    {% set verbose = printer["gcode_macro _USER_VARIABLES"].verbose %}
    {% set status_leds_enabled = printer["gcode_macro _USER_VARIABLES"].status_leds_enabled %}

    {% set purge_and_brush_enabled = printer["gcode_macro _USER_VARIABLES"].purge_and_brush_enabled %}
    {% set purgeclean_servo_enabled = printer["gcode_macro _USER_VARIABLES"].purgeclean_servo_enabled %}

    {% set St = printer["gcode_macro _USER_VARIABLES"].travel_speed * 60 %}
    {% set Px, Py, Pz = printer["gcode_macro _USER_VARIABLES"].purge_bucket_xyz|map('float') %}

    {% set max_x = printer.toolhead.axis_maximum.x|float %}
    {% set max_y = printer.toolhead.axis_maximum.y|float %}

    {% if status_leds_enabled %}
        STATUS_LEDS COLOR="HEATING"
    {% endif %}

    {% if verbose %}
        RESPOND MSG="Extruder heating to print temperature..."
    {% endif %}

    _CONDITIONAL_MOVE_TO_PURGE_BUCKET
    {% if not purge_and_brush_enabled %}
        G0 X{max_x|int / 2} Y{max_y|int / 3} Z50 F{St}
    {% endif %}

    M109 S{EXTRUDER_TEMP}

    {% if purgeclean_servo_enabled %}
        _SERVO_RETRACT ITEM="purge"
    {% endif %}

    {% if verbose %}
        RESPOND MSG="Extruder temperature OK"
    {% endif %}


[gcode_macro _MODULE_PURGE]
gcode:
    # ----- PURGE AND CLEAN ---------------------------------
    # Just put the nozzle ontop of the purge bucket to purge some material. Keep in mind that
    # if the hotend is not at the minimal extrude temperature, it will be heated up before purging
    {% set EXTRUDER_TEMP = printer["gcode_macro START_PRINT"].extruder_temp %}

    {% set purge_and_brush_enabled = printer["gcode_macro _USER_VARIABLES"].purge_and_brush_enabled %}

    {% if purge_and_brush_enabled %}
        PURGE TEMP={EXTRUDER_TEMP}
    {% endif %}


[gcode_macro _MODULE_CLEAN]
gcode:
    # ----- PURGE AND CLEAN ---------------------------------
    # Just put the nozzle on the brush and clean it. Keep in mind that it's better to do
    # it with the hotend at material temperature but you can also do it at any time if needed
    {% set purge_and_brush_enabled = printer["gcode_macro _USER_VARIABLES"].purge_and_brush_enabled %}
    {% set force_homing_before_brush = printer["gcode_macro _USER_VARIABLES"].force_homing_before_brush %}

    {% if purge_and_brush_enabled %}
        {% if force_homing_before_brush %}
            G28 Z # perform homing before going to the brush to avoid a miss or crash
        {% endif %}
        CLEAN_NOZZLE
    {% endif %}


[gcode_macro _MODULE_Z_CALIB]
gcode:
    # ----- Z CALIBRATION --------------------------------
    # If auto z calibration plugin is enabled, we measure the nozzle height using the physical Z endstop probe, followed by
    # a measurement of the probe on the physical Z endstop probe, and then a measurement of the center of the bed (or mesh)
    # If it's a TAP probe or inductive probe or no Z calibration, then it's only a G28 Z to get a correct Z offset measurement
    {% set zcalib_plugin_enabled = printer["gcode_macro _USER_VARIABLES"].zcalib_plugin_enabled %}

    {% if zcalib_plugin_enabled %}
        G28 Z
        CALIBRATE_Z
    {% else %}
        G28 Z
    {% endif %}


[gcode_macro _MODULE_BED_MESH]
gcode:
    # ----- BED MESH -------------------------------------------
    {% set FL_SIZE = printer["gcode_macro START_PRINT"].fl_size %}
    {% set BED_MESH_PROFILE = printer["gcode_macro START_PRINT"].bed_mesh_profile %}

    {% set verbose = printer["gcode_macro _USER_VARIABLES"].verbose %}
    {% set bed_mesh_enabled = printer["gcode_macro _USER_VARIABLES"].bed_mesh_enabled %}
    {% set status_leds_enabled = printer["gcode_macro _USER_VARIABLES"].status_leds_enabled %}

    {% if bed_mesh_enabled %}
        {% if BED_MESH_PROFILE == "" %}
            {% if verbose %}
                RESPOND MSG="Bed mesh measurement..."
            {% endif %}
            ADAPTIVE_BED_MESH SIZE={FL_SIZE}
        {% else %}
            {% if verbose %}
                RESPOND MSG="Load bed mesh profile : {BED_MESH_PROFILE}"
            {% endif %}
            BED_MESH_PROFILE LOAD={BED_MESH_PROFILE}
        {% endif %}
    {% endif %}


[gcode_macro _MODULE_EXTRUDER_PREHEATING]
gcode:
    # Preheat the nozzle to safe probing temperature.
    {% set safe_extruder_temp = printer["gcode_macro _USER_VARIABLES"].safe_extruder_temp|float %}
    {% set status_leds_enabled = printer["gcode_macro _USER_VARIABLES"].status_leds_enabled %}
    {% set probe_type_enabled = printer["gcode_macro _USER_VARIABLES"].probe_type_enabled %}
    {% set verbose = printer["gcode_macro _USER_VARIABLES"].verbose %}

    {% if status_leds_enabled %}
        STATUS_LEDS COLOR="HEATING"
    {% endif %}
    {% if verbose %}
        RESPOND MSG="Pre-heating the nozzle to a safe temperature..."
    {% endif %}

    {% if probe_type_enabled == "vorontap" %}
        M109 S{safe_extruder_temp}
        {% if verbose %}
            RESPOND MSG="Extruder at safe temperature of {safe_extruder_temp} degrees"
        {% endif %}        
    {% else %}
        {% if printer.extruder.target < safe_extruder_temp %}
            M104 S{safe_extruder_temp} 
            {% if verbose %}
                RESPOND MSG="Extruder is heating at temperature of {safe_extruder_temp} degrees"
            {% endif %}
        {% else %}
            {% if verbose %}
                RESPOND MSG="Extruder is already hot"
            {% endif %}
        {% endif %}
    {% endif %}



[gcode_macro PARK]
description: Park the toolhead at the back and retract some filament if the nozzle is hot
gcode:
    {% set verbose = printer["gcode_macro _USER_VARIABLES"].verbose %}
    {% set material = printer['gcode_macro START_PRINT'].material %}

    {% set Px, Py = printer["gcode_macro _USER_VARIABLES"].park_position_xy|map('float') %}
    {% set Px = params.X|default(Px)|float %}
    {% set Py = params.Y|default(Py)|float %}
    
    {% set park_lift_z = printer["gcode_macro _USER_VARIABLES"].park_lift_z %}
    {% set Z_HOP = params.Z_HOP|default(park_lift_z)|float %}
    {% set firmware_retraction_enabled = printer["gcode_macro _USER_VARIABLES"].firmware_retraction_enabled %}

    {% set St = printer["gcode_macro _USER_VARIABLES"].travel_speed * 60 %}
    {% set Sz = printer["gcode_macro _USER_VARIABLES"].z_drop_speed * 60 %}

    {% set max_z = printer.toolhead.axis_maximum.z - printer.gcode_move.homing_origin.z |float %}
    {% set act_z = printer.toolhead.position.z|float %}

    {% set z_safe = act_z + Z_HOP %}
    {% if z_safe > max_z %}
        {% set z_safe = max_z %}
    {% endif %}

    {% if printer.toolhead.homed_axes != "xyz" %}
        {action_raise_error("Cannot park the toolhead because axis are not homed!")}
    {% endif %}
    
    SAVE_GCODE_STATE NAME=PARK

    {% if printer.extruder.can_extrude %}
        {% if params.E is defined %}
            {% set E = params.E|float|abs %}

            {% if verbose %}
                RESPOND MSG="Retraction overrided with parameter, Extruder retraction = {E}"
            {% endif %}            
        {% else %}
            {% if firmware_retraction_enabled %}    # use firmware_retraction parameter for retract (in case firmware retraction is selected in printer.cfg)
                {% if verbose %}
                    RESPOND MSG="Firmware retraction enabled, Extruder retraction = {printer.firmware_retraction.retract_length}"
                {% endif %}
                G10
            {% else %}                              # otherwise:
                {% if printer["gcode_macro _USER_VARIABLES"].material_parameters[material] is defined %}          # use material parameter if available for retract, otherwise use default value
                    {% set E = printer["gcode_macro _USER_VARIABLES"].material_parameters[material].retract_length|default(1.7) %}
                {% else %}
                    {% set E = 1.7 %}
                {% endif %}

                {% if verbose %}
                    RESPOND MSG="Firmware retraction disabled, Extruder retraction = {E}"
                {% endif %}
            {% endif %}
        {% endif %}

        {% if E is defined and E > 0 %}
            G92 E0
            G1 E-{E} F2100
        {% endif %}
    {% endif %}

    G90
    G1 Z{z_safe} F{Sz}
    G0 X{Px} Y{Py} F{St}
    
    RESTORE_GCODE_STATE NAME=PARK

[gcode_macro PARK_FRONT]
description: Park the toolhead on the front of the printer for maintenance
gcode:
    {% set St = printer["gcode_macro _USER_VARIABLES"].travel_speed * 60 %}
    {% set Sz = printer["gcode_macro _USER_VARIABLES"].z_drop_speed * 60 %}

    {% if printer.toolhead.homed_axes != "xyz" %}
        {action_raise_error("Cannot park the toolhead in maintenance position because axis are not homed!")}
    {% endif %}

    SAVE_GCODE_STATE NAME=PARK_FRONT

    G90      ; absolute positioning
    G0 Z{printer.toolhead.axis_maximum.z/3*2} F{Sz}
    G0 X{printer.toolhead.axis_maximum.x/2} Y{printer.toolhead.axis_minimum.y+10} F{St}

    RESTORE_GCODE_STATE NAME=PARK_FRONT






[gcode_macro END_PRINT]
description: Stop the print and filter the atmosphere for 10min before shuting down
gcode:
    {% set disable_motors_in_end_print = printer["gcode_macro _USER_VARIABLES"].disable_motors_in_end_print %}
    {% set turn_off_heaters_in_end_print = printer["gcode_macro _USER_VARIABLES"].turn_off_heaters_in_end_print %}
    {% set safe_extruder_temp = printer["gcode_macro _USER_VARIABLES"].safe_extruder_temp|float %}
    {% set light_intensity_end_print = printer["gcode_macro _USER_VARIABLES"].light_intensity_end_print %}
    {% set filter_enabled = printer["gcode_macro _USER_VARIABLES"].filter_enabled %}
    {% set light_enabled = printer["gcode_macro _USER_VARIABLES"].light_enabled %}
    {% set status_leds_enabled = printer["gcode_macro _USER_VARIABLES"].status_leds_enabled %}
    {% set bed_mesh_enabled = printer["gcode_macro _USER_VARIABLES"].bed_mesh_enabled %}
    {% set filter_default_time = printer["gcode_macro _USER_VARIABLES"].filter_default_time_on_end_print|default(600)|int %}
    {% set filament_sensor_enabled = printer["gcode_macro _USER_VARIABLES"].filament_sensor_enabled %}
    {% set hotend_fan_tach_enabled = printer["gcode_macro _USER_VARIABLES"].hotend_fan_tach_enabled %}

    PARK

    {% elif printer.extruder.can_extrude %}
        # pull back the filament a little bit
        G92 E0
        G1 E-10 F2100
    {% endif %}

    {% if turn_off_heaters_in_end_print %}
        TURN_OFF_HEATERS
    {% else %}
        SET_HEATER_TEMPERATURE HEATER=extruder TARGET={safe_extruder_temp}
    {% endif %}

    {% if hotend_fan_tach_enabled %}
        UPDATE_DELAYED_GCODE ID=_BACKGROUND_HOTEND_TACHO_CHECK DURATION=0
    {% endif %}

    M107
    M400

    {% if bed_mesh_enabled %}
        BED_MESH_CLEAR
    {% endif %}

    {% if disable_motors_in_end_print %}
        M84
    {% endif %}


    # If a filter is connected, and used during the print, continue filtering the air
    # for a couple of min before stopping everything
    {% if filter_enabled %}
        {% if printer['fan_generic nevermore'].speed > 0 %}  #USE VARIABLE HERE LATER
            {% set FILTER_TIME = params.FILTER_TIME|default(filter_default_time)|int %}
            START_FILTER SPEED=1
            UPDATE_DELAYED_GCODE ID=_STOP_FILTER_DELAYED DURATION={FILTER_TIME}
        {% endif %}
    {% endif %}

    {% if light_enabled %}
        LIGHT_ON S={light_intensity_end_print}
    {% endif %}
    {% if status_leds_enabled %}
        STATUS_LEDS COLOR="DONE_PRINTING"
    {% endif %}

    # If a filament sensor is connected, re-enable it in case it was disabled during printing
    {% if filament_sensor_enabled %}
        SET_FILAMENT_SENSOR SENSOR="runout_sensor" ENABLE=1
    {% endif %}






[gcode_macro _OFF]
description: Turn off the printer
gcode:
    {% set light_enabled = printer["gcode_macro _USER_VARIABLES"].light_enabled %}
    {% set status_leds_enabled = printer["gcode_macro _USER_VARIABLES"].status_leds_enabled %} 
    {% set display_leds_enabled = printer["gcode_macro _USER_VARIABLES"].status_leds_minidisplay_enabled %}
    M84                                                             ; turn steppers off
    TURN_OFF_HEATERS                                                ; turn bed / hotend off
    M107                                                            ; turn print cooling fan off
    {% if light_enabled %}
        LIGHT_OFF                                                   ; turn off light
    {% endif %}
    {% if status_leds_enabled %}
        STATUS_LEDS COLOR="SHUTDOWN"                                     ; turn off status LEDs
    {% endif %}
    {% if display_leds_enabled %}
        _SET_ALLLEDS_BY_NAME LEDS="minidisplay" COLOR="shutdown"    ; turn off all minidisplay LEDs even in knob only mode
    {% endif %}

[gcode_macro SHUTDOWN]
description: Turn off the printer and shutdown the host
gcode:
    _OFF                                               ; Shortcut to turn everything off (see above for this macro)
    {action_respond_info('action:poweroff')}          ; OctoPrint compatible host shutdown
	{action_call_remote_method("shutdown_machine")}   ; Moonraker compatible host shutdown









[gcode_macro CANCEL_PRINT]
rename_existing: BASE_CANCEL_PRINT
description: Cancel the print, retract 10mm of filament and park
gcode:
    {% set turn_off_heaters_in_end_print = printer["gcode_macro _USER_VARIABLES"].turn_off_heaters_in_end_print %}
    {% set safe_extruder_temp = printer["gcode_macro _USER_VARIABLES"].safe_extruder_temp|float %}
    {% set light_intensity_end_print = printer["gcode_macro _USER_VARIABLES"].light_intensity_end_print %}
    {% set filter_enabled = printer["gcode_macro _USER_VARIABLES"].filter_enabled %}
    {% set light_enabled = printer["gcode_macro _USER_VARIABLES"].light_enabled %}
    {% set status_leds_enabled = printer["gcode_macro _USER_VARIABLES"].status_leds_enabled %}
    {% set bed_mesh_enabled = printer["gcode_macro _USER_VARIABLES"].bed_mesh_enabled %}
    {% set filament_sensor_enabled = printer["gcode_macro _USER_VARIABLES"].filament_sensor_enabled %}
    {% set filter_default_time = printer["gcode_macro _USER_VARIABLES"].filter_default_time_on_end_print|default(600)|int %}
    {% set hotend_fan_tach_enabled = printer["gcode_macro _USER_VARIABLES"].hotend_fan_tach_enabled %}

    PARK

    {% elif printer.extruder.can_extrude %}
        # Pull back the filament a little bit
        G92 E0
        G1 E-10 F2100
    {% endif %}

    {% if turn_off_heaters_in_end_print %}
        TURN_OFF_HEATERS
    {% else %}
        SET_HEATER_TEMPERATURE HEATER=extruder TARGET={safe_extruder_temp}
    {% endif %}

    {% if hotend_fan_tach_enabled %}
        UPDATE_DELAYED_GCODE ID=_BACKGROUND_HOTEND_TACHO_CHECK DURATION=0
    {% endif %}

    M107
    M400

    CLEAR_PAUSE

    {% if bed_mesh_enabled %}
        BED_MESH_CLEAR
    {% endif %}

    SDCARD_RESET_FILE

    # If a filter is connected, and used during the print, continue filtering the air
    # for a couple of min before stopping everything
    {% if filter_enabled %}
        {% if printer['fan_generic filter'].speed > 0 %}
            {% set FILTER_TIME = params.FILTER_TIME|default(filter_default_time)|int %}
            START_FILTER SPEED=1
            UPDATE_DELAYED_GCODE ID=_STOP_FILTER_DELAYED DURATION={FILTER_TIME}
        {% endif %}
    {% endif %}

    {% if light_enabled %}
        LIGHT_ON S={light_intensity_end_print}
    {% endif %}
    {% if status_leds_enabled %}
        STATUS_LEDS COLOR="OFF"
    {% endif %}

    # If a filament sensor is connected, re-enable it in case it was disabled during printing
    {% if filament_sensor_enabled %}
        SET_FILAMENT_SENSOR SENSOR="runout_sensor" ENABLE=1
    {% endif %}
    
    BASE_CANCEL_PRINT








[gcode_macro _TILT_CALIBRATE]
description: Do a QGL, Z_tilt, etc... depending of the machine configuration
gcode:
    {% set FORCE_OPERATION = params.FORCE|default('true') %}
    {% set conf_QGL = printer["gcode_macro _USER_VARIABLES"].qgl_enabled %}
    {% set conf_ztilt = printer["gcode_macro _USER_VARIABLES"].ztilt_enabled %}
    {% set probe_type_enabled = printer["gcode_macro _USER_VARIABLES"].probe_type_enabled %}
    {% set verbose = printer["gcode_macro _USER_VARIABLES"].verbose %}

    {% if probe_type_enabled == "dockable" %}
        SET_GCODE_VARIABLE MACRO=_PROBE_ON_ERROR_ACTION VARIABLE=probing VALUE=True
    {% endif %}

    {% if conf_QGL %}
        {% if printer.quad_gantry_level.applied|lower == 'false' or FORCE_OPERATION|lower == 'true' %}
            {% if verbose %}
                RESPOND MSG="QGL..."
            {% endif %}
            QUAD_GANTRY_LEVEL
        {% endif %}
    {% elif conf_ztilt %}
        {% if printer.z_tilt.applied|lower == 'false' or FORCE_OPERATION|lower == 'true' %}
            {% if verbose %}
                RESPOND MSG="Z tilt adjust..."
            {% endif %}
            Z_TILT_ADJUST
        {% endif %}
    {% else %}
        {% if verbose %}
            RESPOND MSG="No tilt calibration needed on this machine. Continuing..."
        {% endif %}
    {% endif %}

    {% if probe_type_enabled == "dockable" %}
        SET_GCODE_VARIABLE MACRO=_PROBE_ON_ERROR_ACTION VARIABLE=probing VALUE=False
    {% endif %}



    














[gcode_macro PAUSE]
rename_existing: BASE_PAUSE
description: Pause the print and park
gcode:
    {% set light_enabled = printer["gcode_macro _USER_VARIABLES"].light_enabled %}
    {% set light_intensity_start_print = printer["gcode_macro _USER_VARIABLES"].light_intensity_start_print %}

    {% if printer.pause_resume.is_paused %}
        RESPOND MSG="Print is already paused"
    {% else %}
        SAVE_GCODE_STATE NAME=PAUSE_state
        {% if light_enabled %}
            LIGHT_ON S={light_intensity_start_print}
        {% endif %}
        BASE_PAUSE
        PARK
    {% endif %}


[gcode_macro RESUME]
rename_existing: BASE_RESUME
description: Resume the print after an optional unretract
gcode:
    {% set St = printer["gcode_macro _USER_VARIABLES"].travel_speed %}
    {% set light_enabled = printer["gcode_macro _USER_VARIABLES"].light_enabled %}
    {% set light_intensity_printing = printer["gcode_macro _USER_VARIABLES"].light_intensity_printing %}

    {% if not printer.pause_resume.is_paused %}
        RESPOND MSG="Print is not paused. Resume ignored"
    {% else %}
        RESTORE_GCODE_STATE NAME=PAUSE_state MOVE=1 MOVE_SPEED={St}
        {% if light_enabled %}
            LIGHT_ON S={light_intensity_printing}
        {% endif %}
        BASE_RESUME
    {% endif %}





    
[gcode_macro ACTIVATE_PROBE]
description: Put the machine in a state being able to probe
variable_temperature: 0
gcode:
    {% set LOCK = params.LOCK|default(False, boolean=true) %}

    {% set probe_type_enabled = printer["gcode_macro _USER_VARIABLES"].probe_type_enabled %}
    {% set tap_max_probing_temp = printer["gcode_macro _USER_VARIABLES"].tap_max_probing_temp|float %}

    # If a dockable probe is defined, then check and ATTACH the probe
    {% if probe_type_enabled == "dockable" or probe_type_enabled == "dockable_virtual" %}
        _CHECK_PROBE action=query
        {% if LOCK %}
            _ATTACH_PROBE_LOCK
        {% else %}
            _ATTACH_PROBE
        {% endif %}

    # If a Voron TAP probe is defined, then check the temperature and lower it if needed
    {% elif probe_type_enabled == "vorontap" %}
        SAVE_GCODE_STATE NAME=BEFORE_TAP_ACTION

        {% set ACTUAL_TEMP = printer.extruder.temperature %}
        {% set TARGET_TEMP = printer.extruder.target %}

        SET_GCODE_VARIABLE MACRO=ACTIVATE_PROBE VARIABLE=temperature VALUE={TARGET_TEMP}

        {% if TARGET_TEMP > tap_max_probing_temp %}
            { action_respond_info('Extruder temperature target of %.1fC is too high for TAP probing, lowering to %.1fC' % (TARGET_TEMP, tap_max_probing_temp)) }
            M106 S255 ; 100% the part cooling fan to help the extruder cooling
            M109 S{tap_max_probing_temp}
            M106 S0   ; Stop the part cooling fan
        {% else %}
            # Temperature target is already low enough, but nozzle may still be too hot
            {% if ACTUAL_TEMP > tap_max_probing_temp + 3 %}
                M106 S255 ; 100% the part cooling fan to help the extruder cooling
                TEMPERATURE_WAIT SENSOR=extruder MAXIMUM={tap_max_probing_temp}
                M106 S0   ; Stop the part cooling fan
            {% endif %}
        {% endif %}
    {% endif %}


[gcode_macro DEACTIVATE_PROBE]
description: Revert the machine to a normal state after probing
gcode:
    {% set UNLOCK = params.UNLOCK|default(False, boolean=true) %}

    {% set probe_type_enabled = printer["gcode_macro _USER_VARIABLES"].probe_type_enabled %}
    {% set tap_deactivation_zhop = printer["gcode_macro _USER_VARIABLES"].tap_deactivation_zhop %}
    {% set Sz = printer["gcode_macro _USER_VARIABLES"].z_drop_speed * 60 %}

    # If a dockable probe is defined, then check and DETTACH the probe
    {% if probe_type_enabled == "dockable" or probe_type_enabled == "dockable_virtual" %}
        _CHECK_PROBE action=query
        {% if UNLOCK %}
            _DOCK_PROBE_UNLOCK
        {% else %}
            _DOCK_PROBE
        {% endif %}

    # If a Voron TAP probe is defined, then check and restore the nozzle temperature if needed
    {% elif probe_type_enabled == "vorontap" %}
        # Small Z hop to avoid restoring the temperature directly on the PEI
        {% set z_safe = printer.toolhead.position.z + tap_deactivation_zhop %}
        {% if z_safe > printer.toolhead.axis_maximum.z %}
            {% set z_safe = printer.toolhead.axis_maximum.z %}
        {% endif %}
        G90
        G1 Z{z_safe} F{Sz}

        # Then restoring the temperature
        {% set old_target_temperature = printer["gcode_macro ACTIVATE_PROBE"].temperature %}
        M109 S{old_target_temperature}

        RESTORE_GCODE_STATE NAME=BEFORE_TAP_ACTION
    {% endif %}

    
[gcode_macro START_FILTER]
gcode:
    {% set SPEED = params.SPEED|default(1)|float %}

    {% set filter_name = printer["gcode_macro _USER_VARIABLES"].filter_name %}
    SET_FAN_SPEED FAN={filter_name} SPEED={SPEED}


[gcode_macro STOP_FILTER]
gcode:
    {% set filter_name = printer["gcode_macro _USER_VARIABLES"].filter_name %}
    SET_FAN_SPEED FAN={filter_name} SPEED=0


[delayed_gcode _STOP_FILTER_DELAYED]
gcode:
    STOP_FILTER

###################################
#	Park front for nozzle change (https://ellis3dp.com/Print-Tuning-Guide/articles/useful_macros/parking.html)
###################################

[gcode_macro CHANGE_FILAMENT]
description: Do a PAUSE, park the toolhead over the purge bucket and unload the filament
gcode:
    {% set TEMP = params.TEMP|default(printer["gcode_macro _USER_VARIABLES"].print_default_extruder_temp)|float %}
    {% set DISTANCE = params.DISTANCE|default(105)|float %}

    SAVE_GCODE_STATE NAME=CHANGE_FILAMENT_state
    PAUSE
    _CONDITIONAL_MOVE_TO_PURGE_BUCKET Z_DROP=0
    UNLOAD_FILAMENT TEMP={TEMP} DISTANCE={DISTANCE}
    RESTORE_GCODE_STATE NAME=CHANGE_FILAMENT_state


[gcode_macro UNLOAD_FILAMENT]
description: Basic unload of the filament (used with M600/CHANGE_FILAMENT)
gcode:
    {% set TEMP = params.TEMP|default(printer["gcode_macro _USER_VARIABLES"].print_default_extruder_temp)|float %}
    {% set DISTANCE = params.DISTANCE|default(105)|float %}

    {% set verbose = printer["gcode_macro _USER_VARIABLES"].verbose %}
    {% set filament_sensor_enabled = printer["gcode_macro _USER_VARIABLES"].filament_sensor_enabled %}
    {% set klippain_mmu_enabled = printer["gcode_macro _USER_VARIABLES"].klippain_mmu_enabled %}
    {% set re_enable_filament_sensor = 0 %}

    {% if filament_sensor_enabled %}
        {% if (printer['filament_motion_sensor runout_sensor'] is defined and printer['filament_motion_sensor runout_sensor'].enabled) or (printer['filament_switch_sensor runout_sensor'] is defined and printer['filament_switch_sensor runout_sensor'].enabled) %}
            SET_FILAMENT_SENSOR SENSOR="runout_sensor" ENABLE=0
            {% set re_enable_filament_sensor = 1 %}
            {% if verbose %}
                RESPOND MSG="Runout sensor deactivated to unload filament"
            {% endif %}
        {% endif %}
    {% endif %}

    {% if klippain_mmu_enabled %}
        _KLIPPAIN_MMU_SET_CLOGDETECTION STATE=0
    {% endif %}

    SAVE_GCODE_STATE NAME=UNLOAD_FILAMENT_state
    _LOW_TEMP_CHECK T={TEMP}

    _TIP_SHAPING
    M83
    G1 E-20 F3600
    G4 P3000
    G1 E{DISTANCE|float * -1} F3000

    # Flushing Klipper's buffer to ensure the unload is done before continuing
    M400

    RESTORE_GCODE_STATE NAME=UNLOAD_FILAMENT_state

    {% if filament_sensor_enabled and re_enable_filament_sensor %}
        SET_FILAMENT_SENSOR SENSOR="runout_sensor" ENABLE=1
        {% if verbose %}
            RESPOND MSG="Filament unloaded, runout sensor reactivated"
        {% endif %}
    {% endif %}

    {% if klippain_mmu_enabled %}
        _KLIPPAIN_MMU_SET_CLOGDETECTION STATE={printer.mmu.clog_detection}
    {% endif %}


[gcode_macro LOAD_FILAMENT]
description: Basic load of the filament (used with M600/CHANGE_FILAMENT)
gcode:
    {% set TEMP = params.TEMP|default(printer["gcode_macro _USER_VARIABLES"].print_default_extruder_temp)|float %}
    {% set DISTANCE = params.DISTANCE|default(105)|float %}

    {% set verbose = printer["gcode_macro _USER_VARIABLES"].verbose %}
    {% set filament_sensor_enabled = printer["gcode_macro _USER_VARIABLES"].filament_sensor_enabled %}
    {% set klippain_mmu_enabled = printer["gcode_macro _USER_VARIABLES"].klippain_mmu_enabled %}
    {% set re_enable_filament_sensor = 0 %}

    {% if filament_sensor_enabled %}
        {% if (printer['filament_motion_sensor runout_sensor'] is defined and printer['filament_motion_sensor runout_sensor'].enabled) or (printer['filament_switch_sensor runout_sensor'] is defined and printer['filament_switch_sensor runout_sensor'].enabled) %}
            SET_FILAMENT_SENSOR SENSOR="runout_sensor" ENABLE=0
            {% set re_enable_filament_sensor = 1 %}
            {% if verbose %}
                RESPOND MSG="Runout sensor deactivated to load filament"
            {% endif %}
        {% endif %}
    {% endif %}

    {% if klippain_mmu_enabled %}
        _KLIPPAIN_MMU_SET_CLOGDETECTION STATE=0
    {% endif %}

    SAVE_GCODE_STATE NAME=LOAD_FILAMENT_state
    _LOW_TEMP_CHECK T={TEMP}
    M83
    G92 E0
    G1 E{DISTANCE|float} F200
    G1 E50 F150

    # Flushing Klipper's buffer to ensure the load is done before continuing
    M400

    G92 E0
    RESTORE_GCODE_STATE NAME=LOAD_FILAMENT_state

    {% if filament_sensor_enabled and re_enable_filament_sensor %}
        SET_FILAMENT_SENSOR SENSOR="runout_sensor" ENABLE=1
        {% if verbose %}
            RESPOND MSG="Filament loaded, runout sensor reactivated"
        {% endif %}
    {% endif %}

    {% if klippain_mmu_enabled %}
        _KLIPPAIN_MMU_SET_CLOGDETECTION STATE={printer.mmu.clog_detection}
    {% endif %}


[gcode_macro _TIP_SHAPING]
description: Filament tip shaping sequence
gcode:
    {% set TEMP = params.TEMP|default(printer["gcode_macro _USER_VARIABLES"].print_default_extruder_temp)|float %}

    {% set verbose = printer["gcode_macro _USER_VARIABLES"].verbose %}
    {% set filament_sensor_enabled = printer["gcode_macro _USER_VARIABLES"].filament_sensor_enabled %}
    {% set klippain_mmu_enabled = printer["gcode_macro _USER_VARIABLES"].klippain_mmu_enabled %}
    {% set re_enable_filament_sensor = 0 %}

    {% if filament_sensor_enabled %}
        {% if (printer['filament_motion_sensor runout_sensor'] is defined and printer['filament_motion_sensor runout_sensor'].enabled) or (printer['filament_switch_sensor runout_sensor'] is defined and printer['filament_switch_sensor runout_sensor'].enabled) %}
            SET_FILAMENT_SENSOR SENSOR="runout_sensor" ENABLE=0
            {% set re_enable_filament_sensor = 1 %}
            {% if verbose %}
                RESPOND MSG="Runout sensor deactivated for filament tip shaping"
            {% endif %}
        {% endif %}
    {% endif %}

     {% if klippain_mmu_enabled %}
        _KLIPPAIN_MMU_SET_CLOGDETECTION STATE=0
    {% endif %}

    SAVE_GCODE_STATE NAME=TIP_SHAPING_state
    _LOW_TEMP_CHECK T={TEMP}

    {% set old_pressure_advance = printer.extruder.pressure_advance|default(0) %} # old pressure advance
    # we suppress pressure advance
    SET_PRESSURE_ADVANCE ADVANCE=0

    M82
    G92 E0
    G1 E2 F3600
    G1 E0 F3600
    G1 E3 F3600
    G1 E0 F3600
    G1 E4 F3600
    G1 E0 F3600

    # set last pressure advance
    SET_PRESSURE_ADVANCE ADVANCE={old_pressure_advance}

    # Flushing Klipper's buffer to ensure the tip shaping sequence is done before continuing
    M400

    RESTORE_GCODE_STATE NAME=TIP_SHAPING_state

    {% if filament_sensor_enabled and re_enable_filament_sensor %}
        SET_FILAMENT_SENSOR SENSOR="runout_sensor" ENABLE=1
        {% if verbose %}
            RESPOND MSG="Filament tip shaping done, runout sensor reactivated"
        {% endif %}
    {% endif %}

    {% if klippain_mmu_enabled %}
        _KLIPPAIN_MMU_SET_CLOGDETECTION STATE={printer.mmu.clog_detection}
    {% endif %}





    

[gcode_macro CHAMBER_LED_ON]
gcode:
    SET_PIN PIN=chamber_led VALUE=0.5
    {action_respond_info("Light on")}

[gcode_macro CHAMBER_LED_OFF]
gcode:
    SET_PIN PIN=chamber_led VALUE=0.0
    {action_respond_info("Light off")}

[gcode_macro NEVERMORE_ON]
description: Turn Nevermore fan on
gcode:
    SET_FAN_SPEED FAN=nevermore SPEED=1.0
    {action_respond_info("Nevermore fan on")}

[gcode_macro NEVERMORE_OFF]
description: Turn Nevermore fan off
gcode:
    SET_FAN_SPEED FAN=nevermore SPEED=0.0
    {action_respond_info("Nevermore fan off")}




[gcode_macro _CG28]
description: Homing only if necessary
gcode:
    {% set status_leds_enabled = printer["gcode_macro _USER_VARIABLES"].status_leds_enabled %}

    {% if "xyz" not in printer.toolhead.homed_axes %}
        {% if status_leds_enabled %}
            STATUS_LEDS COLOR="HOMING"
        {% endif %}
        G28
        {% if status_leds_enabled %}
            STATUS_LEDS COLOR="READY"
        {% endif %}  
    {% endif %}


    

# The following status macro is available:
#    STATUS_LEDS COLOR="xxxxx"

# With additional macros for basic control:
#    SET_NOZZLE_LEDS_ON
#    SET_LOGO_LEDS_OFF
#    SET_NOZZLE_LEDS_OFF

[gcode_macro _SET_LEDS]
gcode:
    {% set red = params.RED|default(0)|float %}
    {% set green = params.GREEN|default(0)|float %}
    {% set blue = params.BLUE|default(0)|float %}
    {% set white = params.WHITE|default(0)|float %}
    {% set led = params.LED|string %}
    {% set idx = (params.IDX|string).split(',') %}
    {% set transmit_last = params.TRANSMIT|default(1) %}
    
    {% if printer["gcode_macro _USER_VARIABLES"].status_leds_effects_enabled %} 
        STOP_LED_EFFECTS LEDS="neopixel:"{led}" ("{params.IDX}")"
    {% endif %}

    {% for led_index in idx %}
        {% set transmit=transmit_last if loop.last else 0 %}
        SET_LED LED={led} RED={red} GREEN={green} BLUE={blue} WHITE={white} INDEX={led_index} TRANSMIT={transmit}
    {% endfor %} 

[gcode_macro _SET_LEDS_BY_NAME]
# set color by led index
gcode:
    {% set leds_name = params.LEDS %}
    {% set color_name = params.COLOR %}
    {% set color = printer["gcode_macro _LEDS_COLORS_DEFINITION"].colors[leds_name][color_name] %}
    {% set led = printer["gcode_macro _USER_VARIABLES"]["status_leds_" + leds_name + "_led_name"] %}
    {% set idx = printer["gcode_macro _USER_VARIABLES"]["status_leds_" + leds_name + "_idx"] %}
    {% set transmit = params.TRANSMIT|default(1) %}

    _SET_LEDS LED={led} RED={color.r} GREEN={color.g} BLUE={color.b} WHITE={color.w} IDX="{idx}" TRANSMIT={transmit}

[gcode_macro _SET_ALLLEDS_BY_NAME]
# set same color for all leds
gcode:
    {% set leds_name = params.LEDS %}
    {% set color_name = params.COLOR %}
    {% set led = printer["gcode_macro _USER_VARIABLES"]["status_leds_" + leds_name + "_led_name"] %}
    {% set color = printer["gcode_macro _LEDS_COLORS_DEFINITION"].colors[leds_name][color_name] %}
    {% set transmit = params.TRANSMIT|default(1) %}

    SET_LED LED={led} RED={color.r} GREEN={color.g} BLUE={color.b} WHITE={color.w}  TRANSMIT={transmit}

[gcode_macro _SET_LOGO_LEDS]
gcode:
    {% set red = params.RED|default(0)|float %}
    {% set green = params.GREEN|default(0)|float %}
    {% set blue = params.BLUE|default(0)|float %}
    {% set white = params.WHITE|default(0)|float %}
    {% set led = printer["gcode_macro _USER_VARIABLES"].status_leds_logo_led_name %}
    {% set idx = printer["gcode_macro _USER_VARIABLES"].status_leds_logo_idx %}
    {% set transmit = params.TRANSMIT|default(1) %}

    _SET_LEDS LED={led} RED={red} green={green} BLUE={blue} WHITE={white} IDX="{idx}" TRANSMIT={transmit}

[gcode_macro _SET_NOZZLE_LEDS]
gcode:
    {% set red = params.RED|default(0)|float %}
    {% set green = params.GREEN|default(0)|float %}
    {% set blue = params.BLUE|default(0)|float %}
    {% set white = params.WHITE|default(0)|float %}
    {% set led = printer["gcode_macro _USER_VARIABLES"].status_leds_nozzle_led_name %}
    {% set idx = printer["gcode_macro _USER_VARIABLES"].status_leds_nozzle_idx %}
    {% set transmit = params.TRANSMIT|default(1) %}

    _SET_LEDS LED={led} RED={red} green={green} BLUE={blue} WHITE={white} IDX="{idx}" TRANSMIT={transmit}

[gcode_macro SET_LOGO_LEDS_OFF]
gcode:
    {% set transmit = params.TRANSMIT|default(1) %}

    _SET_LEDS_BY_NAME LEDS="logo" COLOR="off" TRANSMIT={transmit}

[gcode_macro SET_NOZZLE_LEDS_ON]
gcode:
    {% set transmit = params.TRANSMIT|default(1) %}

    _SET_LEDS_BY_NAME LEDS="nozzle" COLOR="on" TRANSMIT={transmit}

[gcode_macro SET_NOZZLE_LEDS_OFF]
gcode:
    {% set transmit = params.TRANSMIT|default(1) %}

    _SET_LEDS_BY_NAME LEDS="nozzle" COLOR="off" TRANSMIT={transmit}

[gcode_macro STATUS_LEDS]
gcode:
    {% set color = params.COLOR|default('off')|lower %}
    {% set logo_leds_name = printer["gcode_macro _USER_VARIABLES"]["status_leds_logo_led_name"] %}
    {% set nozzle_leds_name = printer["gcode_macro _USER_VARIABLES"]["status_leds_nozzle_led_name"] %}
    {% set logo_transmit = 0 if (logo_leds_name == nozzle_leds_name) else 1 %}

    {% set status_color = {
        'ready': {
            'logo': 'standby',
            'nozzle': 'standby',
            'caselight': 'standby',
            'minidisplay': 'on'
        },
        'busy': {
            'logo': 'busy',
            'nozzle': 'on',
            'caselight': 'busy',
            'minidisplay': 'on'
        },
        'heating': {
            'logo': 'heating',
            'nozzle': 'heating',
            'caselight': 'heating',
            'minidisplay': 'on'
        },
        'leveling': {
            'logo': 'leveling',
            'nozzle': 'on',
            'caselight': 'leveling',
            'minidisplay': 'on'
        },
        'homing': {
            'logo': 'homing',
            'nozzle': 'on',
            'caselight': 'homing',
            'minidisplay': 'on'
        },
        'cleaning': {
            'logo': 'cleaning',
            'nozzle': 'on',
            'caselight': 'cleaning',
            'minidisplay': 'on'
        },
        'meshing': {
            'logo': 'meshing',
            'nozzle': 'on',
            'caselight': 'meshing',
            'minidisplay': 'on'
        },
        'calibrating_z': {
            'logo': 'calibrating_z',
            'nozzle': 'on',
            'caselight': 'calibrating_z',
            'minidisplay': 'on'
        },
        'printing': {
            'logo': 'printing',
            'nozzle': 'on',
            'caselight': 'printing',
            'minidisplay': 'on'
        },
        'printing': {
            'logo': 'printing',
            'nozzle': 'on',
            'caselight': 'printing',
            'minidisplay': 'on'
        },
        'done_printing': {
            'logo': 'done_printing',
            'nozzle': 'done_printing',
            'caselight': 'done_printing',
            'minidisplay': 'off'
        },
        'on': {
            'logo': 'on',
            'nozzle': 'on',
            'caselight': 'on',
            'minidisplay': 'on'
        },        
        'off': {
            'logo': 'off',
            'nozzle': 'off',
            'caselight': 'off',
            'minidisplay': 'off'
        },
        'error': {
            'logo': 'error',
            'nozzle': 'error',
            'caselight': 'error',
            'minidisplay': 'error'
        },        
        'shutdown': {
            'logo': 'off',
            'nozzle': 'off',
            'caselight': 'off',
            'minidisplay': 'shutdown'
        } 
    } %}

    {% if not (color in status_color) %}
        { action_raise_error("COLOR is not valid!") }
    {% endif %}

    {% if printer["gcode_macro _USER_VARIABLES"].status_leds_enabled %}
        {% if printer["gcode_macro _USER_VARIABLES"].status_leds_effects_enabled == False %}
            _SET_LEDS_BY_NAME LEDS="logo" COLOR={status_color[color].logo} TRANSMIT={logo_transmit}
            _SET_LEDS_BY_NAME LEDS="nozzle" COLOR={status_color[color].nozzle} TRANSMIT=1
        {% else %}
            SET_LED_EFFECT EFFECT={"sb_logo_" + status_color[color].logo} REPLACE=1 FADETIME=0.5
            SET_LED_EFFECT EFFECT={"sb_nozzle_" + status_color[color].nozzle} REPLACE=1 FADETIME=0.5
        {% endif %}
    {% endif %}

    {% if printer["gcode_macro _USER_VARIABLES"].status_leds_caselight_enabled%}
        {% if printer["gcode_macro _USER_VARIABLES"].status_leds_effects_enabled == False %}
            _SET_ALLLEDS_BY_NAME LEDS="caselight" COLOR={status_color[color].caselight} TRANSMIT=1
        {% else %}
            SET_LED_EFFECT EFFECT={"cl_" + status_color[color].caselight} REPLACE=1 FADETIME=0.5
        {% endif %}
    {% endif %}

    {% if printer["gcode_macro _USER_VARIABLES"].status_leds_minidisplay_enabled %}
        {% if printer["gcode_macro _USER_VARIABLES"].status_leds_minidisplay_knob_only %}
            _SET_LEDS_BY_NAME LEDS="minidisplay" COLOR={status_color[color].minidisplay} TRANSMIT=1
        {% else %}
            _SET_ALLLEDS_BY_NAME LEDS="minidisplay" COLOR={status_color[color].minidisplay} TRANSMIT=1
        {% endif %}
    {% endif %}






[gcode_macro LIGHT_OFF]
gcode:
    {% set light_pin_name = printer["gcode_macro _USER_VARIABLES"].light_pin_name %}

    set_pin pin={light_pin_name} value=0


[gcode_macro LIGHT_ON]
gcode:
    {% set S = params.S|default(100)|float %}
    {% set light_pin_name = printer["gcode_macro _USER_VARIABLES"].light_pin_name %}

    set_pin pin={light_pin_name} value={S}


[gcode_macro HEATSOAK_CHAMBER]
description: Heatsoak chamber to a specific temperature with a timeout
gcode:
    {% set chamber_sensor_enabled = printer["gcode_macro _USER_VARIABLES"].chamber_temperature_sensor_enabled %}

    {% if chamber_sensor_enabled %}
        {% set SETPOINT_TEMP = params.TEMP|default(0)|float %}
        {% set MAXTIME = params.MAXTIME|default(printer["gcode_macro _USER_VARIABLES"].print_default_chamber_max_heating_time)|int %}

        {% set verbose = printer["gcode_macro _USER_VARIABLES"].verbose %}

        {% for _ in range(1, MAXTIME) %}
            _WAIT_CHAMBER_TEMP TEMP={SETPOINT_TEMP}
        {% endfor %}
        {% if verbose %}
            RESPOND MSG="Chamber temperature OK or timeout reached!"
        {% endif %}
    {% endif %}


[gcode_macro _WAIT_CHAMBER_TEMP]
# This macro is needed to allow klipper populate a new value in the printer[...].temperature variable
# as each variables are populated only once at the beginning of every macro call
gcode:
    {% set chamber_sensor_enabled = printer["gcode_macro _USER_VARIABLES"].chamber_temperature_sensor_enabled %}

    {% if chamber_sensor_enabled %}
        {% set chamber_sensor_name = printer["gcode_macro _USER_VARIABLES"].chamber_temperature_sensor_name %}
        {% set SETPOINT_TEMP = params.TEMP|default(0)|float %}
        {% set CURRENT_TEMP = printer["temperature_sensor " ~ chamber_sensor_name].temperature|float %}

        {% if CURRENT_TEMP <= SETPOINT_TEMP %}
            RESPOND MSG="Heating up the chamber : {CURRENT_TEMP}/{SETPOINT_TEMP}"
            G4 P{60000 * 1} # wait a minute and check again if called in a loop
        {% endif %}
    {% endif %}



[gcode_macro HEATSOAK_BED]
description: Heatsoak bed at specified temperature and wait for a specific amount of time
gcode:
    {% set SETPOINT_TEMP = params.TEMP|default(0)|int %}
    {% set TIME = params.SOAKTIME|default(8)|int %}

    {% set verbose = printer["gcode_macro _USER_VARIABLES"].verbose %}
    {% set heaterbed_enabled = printer["gcode_macro _USER_VARIABLES"].heaterbed_enabled %}
    {% set heatsoak_bed_enabled = printer["gcode_macro _USER_VARIABLES"].print_default_soak > 0 %} # configured heatsoak default value

    {% if heaterbed_enabled %}
        {% if verbose %}
            RESPOND MSG="Heating up bed..."
        {% endif %}

        M190 S{SETPOINT_TEMP}

        {% if TIME > 0 %}
            {% for i in range(0, TIME) %}
                RESPOND MSG="Heatsoak bed, {TIME-i}mn left..."
                G4 P{60000 * 1}
            {% endfor %}
        {% else %}
            {% if heatsoak_bed_enabled %}
                RESPOND MSG="No heatsoak needed, continue"
            {% endif %}
        {% endif %}

        {% if verbose %}
            RESPOND MSG="Bed temperature OK"
        {% endif %}
    
    {% else %}
        {% if verbose %}
            RESPOND MSG="No bed heater defined: nothing to do, continuing..."
        {% endif %}
    {% endif %}







[gcode_macro _CONDITIONAL_MOVE_TO_PURGE_BUCKET]
description: Move over the purge bucket
gcode:
    {% set Z_DROP = params.Z_DROP|default(1)|int %}

    {% set St = printer["gcode_macro _USER_VARIABLES"].travel_speed * 60 %}
    {% set Sz = printer["gcode_macro _USER_VARIABLES"].z_drop_speed * 60 %}
    {% set purge_and_brush_enabled = printer["gcode_macro _USER_VARIABLES"].purge_and_brush_enabled %}
    {% set purgeclean_servo_enabled = printer["gcode_macro _USER_VARIABLES"].purgeclean_servo_enabled %}
    {% set Px, Py, Pz = printer["gcode_macro _USER_VARIABLES"].purge_bucket_xyz|map('float') %}

    # Move to purge zone only if it's available, else just purge where the toolhead is
    {% if purge_and_brush_enabled %}
        SAVE_GCODE_STATE NAME=CONDITIONAL_MOVE_TO_PURGE_BUCKET_STATE
        G90

        {% if Z_DROP == 1 %}
            {% if purgeclean_servo_enabled %}
                G1 Z{Pz} F{Sz} # Secure the Z before deploying the servo
                _SERVO_DEPLOY ITEM="purge"
            {% endif %}
            G1 X{Px} Y{Py} F{St}
            G1 Z{Pz} F{St}
        {% else %}
            # If Z_DROP=0 there is probably some parts on the bed: we do not move the
            # Z axis and purge from an higher position. Also it's risky to use the
            # servo, so better to not do it here...
            G1 X{Px} Y{Py} F{St}
        {% endif %}

        RESTORE_GCODE_STATE NAME=CONDITIONAL_MOVE_TO_PURGE_BUCKET_STATE
    {% endif %}





[gcode_macro PRIMELINE]
gcode:
    # Base macro parameters
    {% set prime_line_length = params.LINE_LENGTH|default(printer["gcode_macro _USER_VARIABLES"].prime_line_length)|float %}
    {% set prime_line_purge_distance = params.PURGE_LENGTH|default(printer["gcode_macro _USER_VARIABLES"].prime_line_purge_distance)|float %}
    {% set prime_line_flowrate = params.FLOWRATE|default(printer["gcode_macro _USER_VARIABLES"].prime_line_flowrate)|float %}
    {% set prime_line_height = params.LINE_HEIGHT|default(printer["gcode_macro _USER_VARIABLES"].prime_line_height)|default(0.6)|float %}
    {% set prime_line_adaptive = params.ADAPTIVE_MODE|default(1)|int %}
    {% set prime_line_margin = params.LINE_MARGIN|default(printer["gcode_macro _USER_VARIABLES"].prime_line_margin)|default(5.0)|float %} # Used only in adaptive mode
    
    # If the SIZE parameter is defined and not a dummy placeholder, we use it to do the adaptive bed mesh logic
    {% set coordinatesFound = false %}
    {% if params.SIZE is defined and params.SIZE != "0_0_0_0" %}
        {% set xMinSpec, yMinSpec, xMaxSpec, yMaxSpec = params.SIZE.split('_')|map('trim')|map('int') %}
        {% set coordinatesFound = true %}
    {% elif printer.exclude_object is defined %}
        {% if printer.exclude_object.objects %}
            # Else if SIZE is not defined, we fallback to use the [exclude_object] tags
            # This method is derived from Kyleisah KAMP repository: https://github.com/kyleisah/Klipper-Adaptive-Meshing-Purging)
            {% set eo_points = printer.exclude_object.objects|map(attribute='polygon')|sum(start=[]) %}
            {% set xMinSpec = eo_points|map(attribute=0)|min %}
            {% set yMinSpec = eo_points|map(attribute=1)|min %}
            {% set xMaxSpec = eo_points|map(attribute=0)|max %}
            {% set yMaxSpec = eo_points|map(attribute=1)|max %}
            {% set coordinatesFound = true %}
        {% endif %}
    {% endif %}

    # We get the default prime line position parameters
    {% set prime_line_x, prime_line_y = printer["gcode_macro _USER_VARIABLES"].prime_line_xy|map('float') %}
    {% set prime_line_x = params.START_X|default(prime_line_x)|float %}
    {% set prime_line_y = params.START_Y|default(prime_line_y)|float %}
    {% set prime_line_direction = params.LINE_DIRECTION|default(printer["gcode_macro _USER_VARIABLES"].prime_line_direction)|string|upper %}

    {% set center_x, center_y = [printer.toolhead.axis_maximum.x / 2, printer.toolhead.axis_maximum.y / 2]|map("float") %}
    
    # If first layer coordinates are retrieved and adaptive mode is enabled, then we replace the coordinates to
    # do an adaptive purge while being careful to have the line stay on the bed when the first layer
    # is in an opposite bed quadrant than the prime line initial coordinates (due to mirrored coordinates from center axes)...
    {% if coordinatesFound and prime_line_adaptive == 1 %}
        {% set prime_line_x = 2*center_x - prime_line_x if (prime_line_x > center_x and xMaxSpec < center_x) or (prime_line_x < center_x and xMinSpec > center_x) 
                               else prime_line_x %}
        {% set prime_line_y = 2*center_y - prime_line_y if (prime_line_y > center_y and yMaxSpec < center_y) or (prime_line_y < center_y and yMinSpec > center_y) 
                               else prime_line_y %}
        {% set prime_line_x = [[prime_line_x, xMinSpec - prime_line_margin]|max, xMaxSpec + prime_line_margin]|min %}
        {% set prime_line_y = [[prime_line_y, yMinSpec - prime_line_margin]|max, yMaxSpec + prime_line_margin]|min %}
    {% endif %}

    # Choose the way of printing the primeline (in + or -) alongside the direction to avoid going outside the bed boundaries
    {% set prime_line_way = -1 if (prime_line_direction == "X" and prime_line_x > center_x) or (prime_line_direction == "Y" and prime_line_y > center_y) else 1 %}

    {% set St = printer["gcode_macro _USER_VARIABLES"].travel_speed * 60 %}
    {% set Sz = printer["gcode_macro _USER_VARIABLES"].z_drop_speed * 60 %}
    {% set verbose = printer["gcode_macro _USER_VARIABLES"].verbose %}

    {% set klippain_mmu_enabled = printer["gcode_macro _USER_VARIABLES"].klippain_mmu_enabled %}
    {% set filament_sensor_enabled = printer["gcode_macro _USER_VARIABLES"].filament_sensor_enabled %}
    {% set re_enable_filament_sensor = 0 %}

    {% set max_extrude_cross_section = printer["configfile"].config["extruder"]["max_extrude_cross_section"]|float %}
    {% set filament_diameter = printer["configfile"].config["extruder"]["filament_diameter"]|float %}
    
    # We first compute the width of the prime line
    {% set purge_volume = prime_line_purge_distance * 3.14159 * (filament_diameter / 2)**2 %}
    {% set line_width = purge_volume / (prime_line_height * prime_line_length) %}

    # Then we check that the prime line cross section will not be problematic (exceeding Klipper max_extrude_cross_section)
    # or, if it's the case, we warn the user and add a correction to the length of filament to be purged
    {% if (prime_line_height * line_width) > max_extrude_cross_section %}
        {% if verbose %}
            {action_respond_info("The prime_line_purge_distance of %.4f mm is too high and will exceed the max_extrude_cross_section!" % prime_line_purge_distance)}
        {% endif %}
        {% set prime_line_purge_distance = 0.98 * (max_extrude_cross_section * prime_line_length) / (3.14159 * (filament_diameter / 2)**2) %}
        {% set purge_volume = prime_line_purge_distance * 3.14159 * (filament_diameter / 2)**2 %}
        {% set line_width = purge_volume / (prime_line_height * prime_line_length) %}
        {% if verbose %}
            {action_respond_info("Klippain corrected the prime_line_purge_distance to %.4f mm" % prime_line_purge_distance)}
        {% endif %}
    {% endif %}

    # We then compute the height to width ratio and validate that the prime line will not be too thin
    {% if (prime_line_height / line_width) >= 0.5 %} # TODO: validate this 1/2 ratio is good for all
        {action_raise_error("The prime line will be too thin and will probably not stick properly to the bed. Increase its purge distance or decrease its length!")}
    {% endif %}

    # Finally we compute the speed to get the correct flowrate for the prime line
    {% set speed = (prime_line_flowrate / (prime_line_height * line_width)) * 60 |float %}

    {% if klippain_mmu_enabled %}
        _KLIPPAIN_MMU_SET_CLOGDETECTION STATE=0
    {% endif %}

    {% if filament_sensor_enabled %}
        {% if (printer['filament_motion_sensor runout_sensor'] is defined and printer['filament_motion_sensor runout_sensor'].enabled) or (printer['filament_switch_sensor runout_sensor'] is defined and printer['filament_switch_sensor runout_sensor'].enabled) %}
            SET_FILAMENT_SENSOR SENSOR="runout_sensor" ENABLE=0
            {% set re_enable_filament_sensor = 1 %}
        {% endif %}
    {% endif %}

    G91
    M83
    {% if (printer.toolhead.position.z < 5) %}
        G1 Z5 F{Sz}
    {% endif %}

    # Starting position
    G90
    G0 X{prime_line_x} Y{prime_line_y} F{St}
    G1 Z{prime_line_height} F{Sz|int / 2}

    # Add pressure in the nozzle
    G92 E0
    G1 E18 F300

    # Prime line
    G92 E0
    {% if prime_line_direction == "X" %}
        G1 X{prime_line_x + prime_line_way*prime_line_length} E{prime_line_purge_distance} F{speed}
    {% elif prime_line_direction == "Y" %}
        G1 Y{prime_line_y + prime_line_way*prime_line_length} E{prime_line_purge_distance} F{speed}
    {% else %}
        { action_respond_error("Prime line direction is not valid. Choose either X or Y in the variables.cfg file!") }
    {% endif %}

    # Retract and Z-hop
    G92 E0
    G1 E-0.2 F2100
    G92 E0
    G1 Z3 F{Sz}

    # Additional small movement to get out of the line as some slicers directly emmit
    # a Z- move as a first step that make the toolhead crash back in the line and get dirty
    G91
    G1 X2 Y2 F{St}
    G90
    
    # Flushing Klipper's buffer to ensure the primeline sequence is done before continuing
    M400

    {% if klippain_mmu_enabled %}
        _KLIPPAIN_MMU_SET_CLOGDETECTION STATE={printer.mmu.clog_detection}
    {% endif %}

    {% if filament_sensor_enabled and re_enable_filament_sensor %}
        SET_FILAMENT_SENSOR SENSOR="runout_sensor" ENABLE=1
    {% endif %}







[gcode_macro _ADAPTIVE_MESH_VARIABLES]
variable_ready: False
variable_do_mesh: False
variable_do_nominal: False
variable_mesh_min: 0,0
variable_mesh_max: 0,0
variable_probe_count: 0,0
variable_algo: "bicubic"
gcode:


[gcode_macro COMPUTE_MESH_PARAMETERS]
description: Compute the mesh parameters and store them for later use
gcode:
    # 1 ----- GET ORIGINAL BEDMESH PARAMS FROM CONFIG ----------------------
    {% set xMinConf, yMinConf = printer["configfile"].config["bed_mesh"]["mesh_min"].split(',')|map('trim')|map('int') %}
    {% set xMaxConf, yMaxConf = printer["configfile"].config["bed_mesh"]["mesh_max"].split(',')|map('trim')|map('int') %}
    {% set xProbeCntConf, yProbeCntConf = printer["configfile"].config["bed_mesh"]["probe_count"].split(',')|map('trim')|map('int') %}
    {% set algo = printer["configfile"].config["bed_mesh"]["algorithm"]|lower %}
    {% set xMeshPPS, yMeshPPS = (printer["configfile"].config["bed_mesh"]["mesh_pps"]|default('2,2')).split(',')|map('trim')|map('int') %}

    {% set margin = params.MARGIN|default(5)|int %} # additional margin to mesh around the first layer
    {% set force_mesh = params.FORCE_MESH|default(False) %} # force the mesh even if it's a small part (ie. computed less than 3x3)


    # 2 ----- GET FIRST LAYER COORDINATES and SIZE -------------------------------------
    # If the SIZE parameter is defined and not a dummy placeholder, we use it to do the adaptive bed mesh logic
    {% set coordinatesFound = false %}
    {% if params.SIZE is defined and params.SIZE != "0_0_0_0" %}
        RESPOND MSG="Got a SIZE parameter for the adaptive bed mesh"
        {% set xMinSpec, yMinSpec, xMaxSpec, yMaxSpec = params.SIZE.split('_')|map('trim')|map('int') %}
        {% set coordinatesFound = true %}

    {% elif printer.exclude_object is defined %}
        {% if printer.exclude_object.objects %}
            # Else if SIZE is not defined, we fallback to use the [exclude_object] tags
            # This method is derived from Kyleisah KAMP repository: https://github.com/kyleisah/Klipper-Adaptive-Meshing-Purging)
            RESPOND MSG="No SIZE parameter, using the [exclude_object] tags for the adaptive bed mesh"
            {% set eo_points = printer.exclude_object.objects|map(attribute='polygon')|sum(start=[]) %}
            {% set xMinSpec = eo_points|map(attribute=0)|min %}
            {% set yMinSpec = eo_points|map(attribute=1)|min %}
            {% set xMaxSpec = eo_points|map(attribute=0)|max %}
            {% set yMaxSpec = eo_points|map(attribute=1)|max %}
            {% set coordinatesFound = true %}
        {% endif %}
    {% endif %}

    {% if not coordinatesFound %}
        # If no SIZE parameter and no [exclude_object] tags, then we want to do a nominal bed mesh
        # so nothing to do here...
        RESPOND MSG="No info about the first layer coordinates, doing a nominal bed mesh instead of adaptive"
    {% endif %}


    # If the first layer size was correctly retrieved, we can do the adaptive bed mesh logic, else we
    # fallback to the original and nominal BED_MESH_CALIBRATE function (full bed probing)
    {% if xMinSpec and yMinSpec and xMaxSpec and yMaxSpec %}

        # 3 ----- APPLY MARGINS ----------------------------------------------
        # We use min/max function as we want it to be constrained by the original
        # bedmesh size. This will avoid going outside the machine limits
        {% set xMin = [xMinConf, (xMinSpec - margin)]|max %}
        {% set xMax = [xMaxConf, (xMaxSpec + margin)]|min %}
        {% set yMin = [yMinConf, (yMinSpec - margin)]|max %}
        {% set yMax = [yMaxConf, (yMaxSpec + margin)]|min %}

        # 4 ----- COMPUTE A NEW PROBE COUNT ----------------------------------
        # The goal is to have at least the same precision as from the config. So we compute an equivalent number
        # of probe points on each X/Y dimensions (distance between two points should be the same as in the config)
        {% set xProbeCnt = ((xMax - xMin) * xProbeCntConf / (xMaxConf - xMinConf))|round(0, 'ceil')|int %}
        {% set yProbeCnt = ((yMax - yMin) * yProbeCntConf / (yMaxConf - yMinConf))|round(0, 'ceil')|int %}

        # Then, three possibilities :
        # a) Both dimensions have less than 3 probe points : the bed_mesh is not needed as it's a small print (if not forced).
        # b) If one of the dimension is less than 3 and the other is greater. The print looks to be elongated and
        #    need the adaptive bed_mesh : we add probing points to the small direction to reach 3 and be able to do it.
        # c) If both direction are greater than 3, we need the adaptive bed_mesh and it's ok.
        # At the end we control (according to Klipper bed_mesh method: "_verify_algorithm") that the computed probe_count is
        # valid according to the choosen algorithm or change it if needed.
        {% if xProbeCnt < 3 and yProbeCnt < 3 %}
            {% if force_mesh %}
                RESPOND MSG="Bed mesh forced (small part detected): meshing 3x3..."
                {% set xProbeCnt = 3 %}
                {% set yProbeCnt = 3 %}
                {% set algo = "lagrange" %}
                {% set mesh_min = "%d,%d"|format(xMin, yMin) %}
                {% set mesh_max = "%d,%d"|format(xMax, yMax) %}
                {% set probe_count = "%d,%d"|format(xProbeCnt, yProbeCnt) %}
                RESPOND MSG="Computed mesh parameters: MESH_MIN={mesh_min} MESH_MAX={mesh_max} PROBE_COUNT={probe_count} ALGORITHM={algo}"
                SET_GCODE_VARIABLE MACRO=_ADAPTIVE_MESH_VARIABLES VARIABLE=do_mesh VALUE={True}
                SET_GCODE_VARIABLE MACRO=_ADAPTIVE_MESH_VARIABLES VARIABLE=do_nominal VALUE={False}
                SET_GCODE_VARIABLE MACRO=_ADAPTIVE_MESH_VARIABLES VARIABLE=mesh_min VALUE='"{mesh_min}"'
                SET_GCODE_VARIABLE MACRO=_ADAPTIVE_MESH_VARIABLES VARIABLE=mesh_max VALUE='"{mesh_max}"'
                SET_GCODE_VARIABLE MACRO=_ADAPTIVE_MESH_VARIABLES VARIABLE=probe_count VALUE='"{probe_count}"'
                SET_GCODE_VARIABLE MACRO=_ADAPTIVE_MESH_VARIABLES VARIABLE=algo VALUE='"{algo}"'
            {% else %}
                RESPOND MSG="Computed mesh parameters: none, bed mesh not needed for very small parts"
                SET_GCODE_VARIABLE MACRO=_ADAPTIVE_MESH_VARIABLES VARIABLE=do_mesh VALUE={False}
            {% endif %}
        {% else %}
            {% set xProbeCnt = [3, xProbeCnt]|max %}
            {% set yProbeCnt = [3, yProbeCnt]|max %}

            # Check of the probe points and interpolation algorithms according to Klipper code
            {% if xMeshPPS != 0 or yMeshPPS != 0 %}
                {% set probeCntMin = [xProbeCnt, yProbeCnt]|min %}
                {% set probeCntMax = [xProbeCnt, yProbeCnt]|max %}
                {% if algo == "lagrange" and probeCntMax > 6 %}
                    # Lagrange interpolation tends to oscillate when using more than 6 samples: swith to bicubic
                    {% set algo = "bicubic" %}
                {% endif %}
                {% if algo == "bicubic" and probeCntMin < 4 %}
                    {% if probeCntMax > 6 %}
                        # Impossible case: need to add probe point on the small axis to be >= 4 (we want 5 to keep it odd)
                        {% if xProbeCnt > yProbeCnt %}
                            {% set yProbeCnt = 5 %}
                        {% else %}
                            {% set xProbeCnt = 5 %}
                        {% endif %}
                    {% else %}
                        # In this case bicubic is not adapted (less than 4 points): switch to lagrange
                        {% set algo = "lagrange" %}
                    {% endif %}
                {% endif %}
            {% endif %}

            # 5 ----- FORMAT THE PARAMETERS AND SAVE THEM ---------------------------
            {% set mesh_min = "%d,%d"|format(xMin, yMin) %}
            {% set mesh_max = "%d,%d"|format(xMax, yMax) %}
            {% set probe_count = "%d,%d"|format(xProbeCnt, yProbeCnt) %}
            RESPOND MSG="Computed mesh parameters: MESH_MIN={mesh_min} MESH_MAX={mesh_max} PROBE_COUNT={probe_count} ALGORITHM={algo}"
            SET_GCODE_VARIABLE MACRO=_ADAPTIVE_MESH_VARIABLES VARIABLE=do_mesh VALUE={True}
            SET_GCODE_VARIABLE MACRO=_ADAPTIVE_MESH_VARIABLES VARIABLE=do_nominal VALUE={False}
            SET_GCODE_VARIABLE MACRO=_ADAPTIVE_MESH_VARIABLES VARIABLE=mesh_min VALUE='"{mesh_min}"'
            SET_GCODE_VARIABLE MACRO=_ADAPTIVE_MESH_VARIABLES VARIABLE=mesh_max VALUE='"{mesh_max}"'
            SET_GCODE_VARIABLE MACRO=_ADAPTIVE_MESH_VARIABLES VARIABLE=probe_count VALUE='"{probe_count}"'
            SET_GCODE_VARIABLE MACRO=_ADAPTIVE_MESH_VARIABLES VARIABLE=algo VALUE='"{algo}"'
        {% endif %}
    {% else %}
        SET_GCODE_VARIABLE MACRO=_ADAPTIVE_MESH_VARIABLES VARIABLE=do_mesh VALUE={True}
        SET_GCODE_VARIABLE MACRO=_ADAPTIVE_MESH_VARIABLES VARIABLE=do_nominal VALUE={True}
    {% endif %}

    # Finaly save in the variables that we already computed the values
    SET_GCODE_VARIABLE MACRO=_ADAPTIVE_MESH_VARIABLES VARIABLE=ready VALUE={True}


[gcode_macro ADAPTIVE_BED_MESH]
description: Perform a bed mesh, but only where and when it's needed
gcode:
    {% set ready = printer["gcode_macro _ADAPTIVE_MESH_VARIABLES"].ready %}

    {% if not 'xyz' in printer.toolhead.homed_axes %}
        { action_raise_error("Must Home printer first!") }
    {% endif %}

    # If the parameters where computed, we can do the mesh by calling the _DO_ADAPTIVE_MESH
    {% if ready %}
        _DO_ADAPTIVE_MESH

    # If the parameters where not computed prior to the ADAPTIVE_BED_MESH call, we call the COMPUTE_MESH_PARAMETERS
    # macro first and then call the _DO_ADAPTIVE_MESH macro after it
    {% else %}
        RESPOND MSG="Adaptive bed mesh: parameters not already computed, automatically calling the COMPUTE_MESH_PARAMETERS macro prior to the mesh"
        COMPUTE_MESH_PARAMETERS {rawparams}
        M400 # mandatory to flush the gcode buffer and be sure to use the last computed parameters
        _DO_ADAPTIVE_MESH
    {% endif %}


[gcode_macro _DO_ADAPTIVE_MESH]
gcode:
    # 1 ----- POPULATE BEDMESH PARAMS FROM SAVED VARIABLES ----------------------
    {% set do_mesh = printer["gcode_macro _ADAPTIVE_MESH_VARIABLES"].do_mesh %}
    {% set do_nominal = printer["gcode_macro _ADAPTIVE_MESH_VARIABLES"].do_nominal %}
    {% set mesh_min = printer["gcode_macro _ADAPTIVE_MESH_VARIABLES"].mesh_min %}
    {% set mesh_max = printer["gcode_macro _ADAPTIVE_MESH_VARIABLES"].mesh_max %}
    {% set probe_count = printer["gcode_macro _ADAPTIVE_MESH_VARIABLES"].probe_count %}
    {% set algo = printer["gcode_macro _ADAPTIVE_MESH_VARIABLES"].algo %}

    # 2 --------- ADAPTIVE_BED_MESH LOGIC --------------------------------------

    # If it's necessary to do a mesh
    {% if do_mesh %}
        # If it's a standard bed_mesh to be done
        {% if do_nominal %}
            RESPOND MSG="Adaptive bed mesh: nominal bed mesh"
            BED_MESH_CALIBRATE
        {% else %}
                RESPOND MSG="Adaptive bed mesh: MESH_MIN={mesh_min} MESH_MAX={mesh_max} PROBE_COUNT={probe_count} ALGORITHM={algo}"
                BED_MESH_CALIBRATE MESH_MIN={mesh_min} MESH_MAX={mesh_max} PROBE_COUNT={probe_count} ALGORITHM={algo}
        {% endif %}
    {% else %}
        RESPOND MSG="Adaptive bed mesh: no mesh to be done"
    {% endif %}

    # Set back the 'ready' parameter to false
    SET_GCODE_VARIABLE MACRO=_ADAPTIVE_MESH_VARIABLES VARIABLE=ready VALUE={False}









[gcode_macro _GOTO_Z_PROBE]
description: Move to z probe avoiding the probe dock
gcode:
    {% set verbose = printer["gcode_macro _USER_VARIABLES"].verbose %}
    {% set zcalib_plugin_enabled = printer["gcode_macro _USER_VARIABLES"].zcalib_plugin_enabled %}
    {% set z_endstop_x, z_endstop_y = printer["gcode_macro _USER_VARIABLES"].zendstop_position|map('float') %}
    {% set homing_travel_speed = printer["gcode_macro _USER_VARIABLES"].homing_travel_speed|float * 60 %}
    {% set current_x = printer.toolhead.position.x|float %}
    {% set current_y = printer.toolhead.position.y|float %}

    SAVE_GCODE_STATE NAME=goto_ZProbe
    G90
    G0 X{z_endstop_x} Y{z_endstop_y} F{homing_travel_speed}

    RESTORE_GCODE_STATE NAME=goto_ZProbe





    # Monitoring loop for hotend fan safety check
[delayed_gcode _BACKGROUND_HOTEND_TACHO_CHECK]
gcode:
    _HOTEND_FAN_CHECK
    UPDATE_DELAYED_GCODE ID=_BACKGROUND_HOTEND_TACHO_CHECK DURATION=3

[gcode_macro _HOTEND_FAN_CHECK]
description: Check the hotend fan tachometer to verify that it is running effectively
variable_he_stop_count: 0
gcode:
    {% set min_rpm = 1000|float %} # This is a relatively low value adapted to all fans to check that they are effectively running
    {% set max_consecutive_stops = 3 %}
    {% set rpm = printer['heater_fan hotend_fan'].rpm|float %}
    {% set he_target = printer[printer.toolhead.extruder].target|float %}
    {% set he_temp = printer[printer.toolhead.extruder].temperature|float %}
    {% set fan_on_temp = printer.configfile.settings['heater_fan hotend_fan'].heater_temp|float %}
    {% set he_stop_count = printer["gcode_macro _HOTEND_FAN_CHECK"].he_stop_count|int %}

    {% if (he_target >= fan_on_temp) and (rpm < min_rpm) and (he_temp >= fan_on_temp) %}
        SET_GCODE_VARIABLE MACRO=_HOTEND_FAN_CHECK VARIABLE=he_stop_count VALUE={he_stop_count + 1}
        RESPOND MSG="Hotend fan stoppage detected for {(he_stop_count+1)*3}sec (max {max_consecutive_stops*3}sec allowed)"
        M400
        {% if printer["gcode_macro _HOTEND_FAN_CHECK"].he_stop_count|int >= max_consecutive_stops-1 %}
            CANCEL_PRINT
        {% endif %}
    {% else %}
        SET_GCODE_VARIABLE MACRO=_HOTEND_FAN_CHECK VARIABLE=he_stop_count VALUE=0
    {% endif %}


[gcode_macro _PART_FAN_CHECK]
description: Check the part fan tachometer to verify that it is running effectively
gcode:
    {% if printer.fan.rpm is not none %}
        {% if printer.fan.rpm > 1000 %} # This is a relatively low value adapted to all fans to check that they are effectively running
            {action_respond_info("Part fan OK!")}
        {% else %}
            M400
            CANCEL_PRINT
            {action_raise_error("Hotend fan stoppage detected, print was canceled!")}
        {% endif %}
    {% endif %}